#version 450

#include "../../TriangleSetupUtil.comp"

layout(local_size_x = 64) in;

layout(push_constant) uniform Transform {
    u32 vertexCount;
    mat4 mvp;
};

layout(set = 0, binding = 0, std140) uniform Config {
    RasterConfig config;
};

layout(set = 1, binding = 1, std430) readonly buffer VertexBuffer {
    vec4 vertecies[];
};

layout(set = 1, binding = 2, std430) readonly buffer VertexColorBuffer {
    vec4 colors[];
};

layout(set = 1, binding = 3, std430) writeonly buffer SetupBlocks {
    TriangleSetupBlock triangleBlocks[];
};

void mark_triangle_discard() {
    triangleBlocks[gl_GlobalInvocationID.x].totalTriangleCount = 0;
}

void main() {
    const u32 triangleCount = vertexCount / 3;
    if (gl_GlobalInvocationID.x >= triangleCount) {
        return;
    }

    vec4 transformedV[3] = {
        mvp * vertecies[3 * gl_GlobalInvocationID.x + 0],
        mvp * vertecies[3 * gl_GlobalInvocationID.x + 1],
        mvp * vertecies[3 * gl_GlobalInvocationID.x + 2]
    };

    // Negative or degenerate W values are rejected
    if (any(lessThanEqual(vec3(transformedV[0].w,
                               transformedV[1].w,
                               transformedV[2].w),
                          vec3(0.0)))) {
        mark_triangle_discard();
        return;
    }

    vec3 barys[6];
    u32 postClipVertexCount = clip(transformedV, barys);

    // no overlap between the triangle and the viewport, the triangle is culled
    // note that values [1,2] shouldn't be possible - if even a single vertex
    //  is inside the viewport, the rest will be clipped
    if (postClipVertexCount == 0) {
        mark_triangle_discard();
        return;
    }

    vec4 localColors[3] = {
        colors[3 * gl_GlobalInvocationID.x + 0],
        colors[3 * gl_GlobalInvocationID.x + 1],
        colors[3 * gl_GlobalInvocationID.x + 2],
    };

    if (!setupTriangle(config,
                       localColors,
                       transformedV,
                       vec3[3](barys[0], barys[1], barys[2]),
                       triangleBlocks[gl_GlobalInvocationID.x])) {
        mark_triangle_discard();
        return;
    }

    triangleBlocks[gl_GlobalInvocationID.x].totalTriangleCount = postClipVertexCount - 2;

    for (u32 i = 2; i < postClipVertexCount - 1; ++i) {
        setupTriangle(config,
                      localColors,
                      transformedV,
                      vec3[3](barys[0], barys[i], barys[i + 1]),
                      triangleBlocks[triangleCount + gl_GlobalInvocationID.x + i - 2]);
    }
}
