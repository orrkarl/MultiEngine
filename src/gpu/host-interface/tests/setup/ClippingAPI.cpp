#include "ClippingAPI.h"

#include "../autogenerated/GPUTestResources.h"

#include "../../../entrypoints/tests/setup/Clipping.h"
#include "../../APIUtils.h"

namespace vkr {
namespace gpu {
namespace tests {

namespace detail {

const size_t ClippingLayout::MODULE_SIZE = device_side::tests::Clipping_comp_count;
const uint32_t* ClippingLayout::MODULE_DATA = device_side::tests::Clipping_comp;
const std::array<VkDescriptorSetLayoutBinding, 3> ClippingLayout::BINDINGS = {
    VkDescriptorSetLayoutBinding { VERTECIES_POS.second,
                                   VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
                                   1,
                                   VkShaderStageFlagBits::VK_SHADER_STAGE_COMPUTE_BIT,
                                   nullptr },
    VkDescriptorSetLayoutBinding { CLIPPED_VERTECIES_POS.second,
                                   VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
                                   1,
                                   VkShaderStageFlagBits::VK_SHADER_STAGE_COMPUTE_BIT,
                                   nullptr },
    VkDescriptorSetLayoutBinding { CLIPPED_VERTEX_COUNTS.second,
                                   VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
                                   1,
                                   VkShaderStageFlagBits::VK_SHADER_STAGE_COMPUTE_BIT,
                                   nullptr },
};
const std::array<uint32_t, 1> ClippingLayout::SETS = { 3 };
const VkPushConstantRange ClippingLayout::PUSH_ARGS = { VkShaderStageFlagBits::VK_SHADER_STAGE_COMPUTE_BIT,
                                                        TRIANGLE_COUNT_OFFSET,
                                                        TRIANGLE_COUNT_SIZE };
const std::array<uint32_t, 3> ClippingLayout::GROUP_SIZES { CLIPPING_LOCAL_SIZE_X,
                                                            CLIPPING_LOCAL_SIZE_Y,
                                                            CLIPPING_LOCAL_SIZE_Z };

} // namespace detail

VkWriteDescriptorSet ClippingAPI::describeVerteciesUpdate(const ArgumentSets& args,
                                                          const VkDescriptorBufferInfo& vertecies) {
    return describeSimpleBufferUpdate(
        args[0], Layout::VERTECIES_POS.second, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, vertecies);
}

VkWriteDescriptorSet ClippingAPI::describeClippedVerteciesUpdate(const ArgumentSets& args,
                                                                 const VkDescriptorBufferInfo& clippedVertecies) {
    return describeSimpleBufferUpdate(
        args[0], Layout::CLIPPED_VERTECIES_POS.second, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, clippedVertecies);
}

VkWriteDescriptorSet ClippingAPI::describeClippedVertexCountsUpdate(const ArgumentSets& args,
                                                                    const VkDescriptorBufferInfo& clippedVertexCounts) {
    return describeSimpleBufferUpdate(
        args[0], Layout::CLIPPED_VERTEX_COUNTS.second, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, clippedVertexCounts);
}

void ClippingAPI::cmdUpdateTriangleCount(VkCommandBuffer cmdBuffer, u32 triangleCount) {
    vkCmdPushConstants(cmdBuffer,
                       m_runnerDesc,
                       VkShaderStageFlagBits::VK_SHADER_STAGE_COMPUTE_BIT,
                       0,
                       sizeof(triangleCount),
                       &triangleCount);
}

void ClippingAPI::cmdDispatch(VkCommandBuffer command, uint32_t triangleCount) {
    cmdUpdateTriangleCount(command, triangleCount);

    uint32_t groupSizeX = dispatchGroupSizes()[0];
    vkCmdDispatch(command, (triangleCount + groupSizeX - 1) / groupSizeX, 1, 1);
}

} // namespace tests
} // namespace gpu
} // namespace vkr
