#include "ClippingAPI.h"

#include "../autogenerated/GPUTestResources.h"

namespace vkr {
namespace tests {
namespace gpu {

ClippingAPI::ClippingAPI()
    : m_clippingCode(VK_NULL_HANDLE), m_argsDesc(VK_NULL_HANDLE), m_clippingRunnerDesc(VK_NULL_HANDLE) {
}

VkResult ClippingAPI::init(VkDevice dev, const VkAllocationCallbacks* allocator) {
    VkResult status = VK_SUCCESS;

    status = initClippingCode(dev, allocator);
    if (status != VK_SUCCESS) {
        return status;
    }

    status = initArgsDescription(dev, allocator);
    if (status != VK_SUCCESS) {
        vkDestroyShaderModule(dev, m_clippingCode, allocator);
        return status;
    }

    status = initClippingDescription(dev, allocator);
    if (status != VK_SUCCESS) {
        vkDestroyDescriptorSetLayout(dev, m_argsDesc, allocator);
        vkDestroyShaderModule(dev, m_clippingCode, allocator);
        return status;
    }

    return VK_SUCCESS;
}

void ClippingAPI::destroy(VkDevice dev, const VkAllocationCallbacks* allocator) {
    vkDestroyPipelineLayout(dev, m_clippingRunnerDesc, allocator);
    vkDestroyDescriptorSetLayout(dev, m_argsDesc, allocator);
    vkDestroyShaderModule(dev, m_clippingCode, allocator);
}

VkDescriptorSetLayout ClippingAPI::describeArguments() {
    return m_argsDesc;
}

VkComputePipelineCreateInfo ClippingAPI::describeRunner() {
    return { VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO,
             nullptr,
             0,
             VkPipelineShaderStageCreateInfo { VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
                                               nullptr,
                                               0,
                                               VkShaderStageFlagBits::VK_SHADER_STAGE_COMPUTE_BIT,
                                               m_clippingCode,
                                               "main",
                                               nullptr },
             m_clippingRunnerDesc,
             VK_NULL_HANDLE,
             0 };
}

VkWriteDescriptorSet ClippingAPI::describeVerteciesUpdate(VkDescriptorSet args,
                                                          const VkDescriptorBufferInfo& rasterConfigBuffer) {
    return { VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
             nullptr,
             args,
             VERTECIES_POS,
             0,
             1,
             VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
             nullptr,
             &rasterConfigBuffer,
             nullptr };
}

VkWriteDescriptorSet ClippingAPI::describeClippedVerteciesUpdate(VkDescriptorSet args,
                                                                 const VkDescriptorBufferInfo& vertexBuffer) {
    return { VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
             nullptr,
             args,
             CLIPPED_VERTECIES_POS,
             0,
             1,
             VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
             nullptr,
             &vertexBuffer,
             nullptr };
}

VkWriteDescriptorSet
ClippingAPI::describeClippedVertexCountsUpdate(VkDescriptorSet args,
                                               const VkDescriptorBufferInfo& colorBuffer) {
    return { VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
             nullptr,
             args,
             CLIPPED_VERTEX_COUNTS_POS,
             0,
             1,
             VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
             nullptr,
             &colorBuffer,
             nullptr };
}

void ClippingAPI::cmdUpdateTriangleCount(VkCommandBuffer cmdBuffer, u32 triangleCount) {
    vkCmdPushConstants(cmdBuffer,
                       m_clippingRunnerDesc,
                       VkShaderStageFlagBits::VK_SHADER_STAGE_COMPUTE_BIT,
                       0,
                       sizeof(triangleCount),
                       &triangleCount);
}

VkResult ClippingAPI::initClippingCode(VkDevice dev, const VkAllocationCallbacks* allocator) {
    VkShaderModuleCreateInfo stageCodeInfo { VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
                                             nullptr,
                                             0,
                                             device_side::tests::Clipping_comp_count * sizeof(uint32_t),
                                             device_side::tests::Clipping_comp };

    return vkCreateShaderModule(dev, &stageCodeInfo, allocator, &m_clippingCode);
}

VkResult ClippingAPI::initArgsDescription(VkDevice dev, const VkAllocationCallbacks* allocator) {
    std::array<VkDescriptorSetLayoutBinding, 3> processedBindings {
        VkDescriptorSetLayoutBinding { VERTECIES_POS,
                                       VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
                                       1,
                                       VkShaderStageFlagBits::VK_SHADER_STAGE_COMPUTE_BIT,
                                       nullptr },
        VkDescriptorSetLayoutBinding { CLIPPED_VERTECIES_POS,
                                       VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
                                       1,
                                       VkShaderStageFlagBits::VK_SHADER_STAGE_COMPUTE_BIT,
                                       nullptr },
        VkDescriptorSetLayoutBinding { CLIPPED_VERTEX_COUNTS_POS,
                                       VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
                                       1,
                                       VkShaderStageFlagBits::VK_SHADER_STAGE_COMPUTE_BIT,
                                       nullptr },
    };
    VkDescriptorSetLayoutCreateInfo layoutInfo { VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
                                                 nullptr,
                                                 0,
                                                 processedBindings.size(),
                                                 processedBindings.data() };

    return vkCreateDescriptorSetLayout(dev, &layoutInfo, allocator, &m_argsDesc);
}

VkResult ClippingAPI::initClippingDescription(VkDevice dev, const VkAllocationCallbacks* allocator) {
    VkPushConstantRange pushArgsDesc { VkShaderStageFlagBits::VK_SHADER_STAGE_COMPUTE_BIT,
                                       0,
                                       sizeof(uint32_t) };
    VkPipelineLayoutCreateInfo pipelineDesc {
        VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO, nullptr, 0, 1, &m_argsDesc, 1, &pushArgsDesc
    };

    return vkCreatePipelineLayout(dev, &pipelineDesc, allocator, &m_clippingRunnerDesc);
}

}
}
}
