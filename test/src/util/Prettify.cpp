#include "Prettify.h"

namespace util {

#define CLERROR_CASE_RET(error)                                                                              \
    case error:                                                                                              \
        return #error

const char* stringifyCLStatus(nr::Status status) {
    switch (status) {
        CLERROR_CASE_RET(CL_SUCCESS);
        CLERROR_CASE_RET(CL_DEVICE_NOT_FOUND);
        CLERROR_CASE_RET(CL_DEVICE_NOT_AVAILABLE);
        CLERROR_CASE_RET(CL_COMPILER_NOT_AVAILABLE);
        CLERROR_CASE_RET(CL_MEM_OBJECT_ALLOCATION_FAILURE);
        CLERROR_CASE_RET(CL_OUT_OF_RESOURCES);
        CLERROR_CASE_RET(CL_OUT_OF_HOST_MEMORY);
        CLERROR_CASE_RET(CL_PROFILING_INFO_NOT_AVAILABLE);
        CLERROR_CASE_RET(CL_MEM_COPY_OVERLAP);
        CLERROR_CASE_RET(CL_IMAGE_FORMAT_MISMATCH);
        CLERROR_CASE_RET(CL_IMAGE_FORMAT_NOT_SUPPORTED);
        CLERROR_CASE_RET(CL_BUILD_PROGRAM_FAILURE);
        CLERROR_CASE_RET(CL_MAP_FAILURE);
        CLERROR_CASE_RET(CL_MISALIGNED_SUB_BUFFER_OFFSET);
        CLERROR_CASE_RET(CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST);
        CLERROR_CASE_RET(CL_COMPILE_PROGRAM_FAILURE);
        CLERROR_CASE_RET(CL_LINKER_NOT_AVAILABLE);
        CLERROR_CASE_RET(CL_LINK_PROGRAM_FAILURE);
        CLERROR_CASE_RET(CL_DEVICE_PARTITION_FAILED);
        CLERROR_CASE_RET(CL_KERNEL_ARG_INFO_NOT_AVAILABLE);
        CLERROR_CASE_RET(CL_INVALID_VALUE);
        CLERROR_CASE_RET(CL_INVALID_DEVICE_TYPE);
        CLERROR_CASE_RET(CL_INVALID_PLATFORM);
        CLERROR_CASE_RET(CL_INVALID_DEVICE);
        CLERROR_CASE_RET(CL_INVALID_CONTEXT);
        CLERROR_CASE_RET(CL_INVALID_QUEUE_PROPERTIES);
        CLERROR_CASE_RET(CL_INVALID_COMMAND_QUEUE);
        CLERROR_CASE_RET(CL_INVALID_HOST_PTR);
        CLERROR_CASE_RET(CL_INVALID_MEM_OBJECT);
        CLERROR_CASE_RET(CL_INVALID_IMAGE_FORMAT_DESCRIPTOR);
        CLERROR_CASE_RET(CL_INVALID_IMAGE_SIZE);
        CLERROR_CASE_RET(CL_INVALID_SAMPLER);
        CLERROR_CASE_RET(CL_INVALID_BINARY);
        CLERROR_CASE_RET(CL_INVALID_BUILD_OPTIONS);
        CLERROR_CASE_RET(CL_INVALID_PROGRAM);
        CLERROR_CASE_RET(CL_INVALID_PROGRAM_EXECUTABLE);
        CLERROR_CASE_RET(CL_INVALID_KERNEL_NAME);
        CLERROR_CASE_RET(CL_INVALID_KERNEL_DEFINITION);
        CLERROR_CASE_RET(CL_INVALID_KERNEL);
        CLERROR_CASE_RET(CL_INVALID_ARG_INDEX);
        CLERROR_CASE_RET(CL_INVALID_ARG_VALUE);
        CLERROR_CASE_RET(CL_INVALID_ARG_SIZE);
        CLERROR_CASE_RET(CL_INVALID_KERNEL_ARGS);
        CLERROR_CASE_RET(CL_INVALID_WORK_DIMENSION);
        CLERROR_CASE_RET(CL_INVALID_WORK_GROUP_SIZE);
        CLERROR_CASE_RET(CL_INVALID_WORK_ITEM_SIZE);
        CLERROR_CASE_RET(CL_INVALID_GLOBAL_OFFSET);
        CLERROR_CASE_RET(CL_INVALID_EVENT_WAIT_LIST);
        CLERROR_CASE_RET(CL_INVALID_EVENT);
        CLERROR_CASE_RET(CL_INVALID_OPERATION);
        CLERROR_CASE_RET(CL_INVALID_GL_OBJECT);
        CLERROR_CASE_RET(CL_INVALID_BUFFER_SIZE);
        CLERROR_CASE_RET(CL_INVALID_MIP_LEVEL);
        CLERROR_CASE_RET(CL_INVALID_GLOBAL_WORK_SIZE);
        CLERROR_CASE_RET(CL_INVALID_PROPERTY);
        CLERROR_CASE_RET(CL_INVALID_IMAGE_DESCRIPTOR);
        CLERROR_CASE_RET(CL_INVALID_COMPILER_OPTIONS);
        CLERROR_CASE_RET(CL_INVALID_LINKER_OPTIONS);
        CLERROR_CASE_RET(CL_INVALID_DEVICE_PARTITION_COUNT);
        CLERROR_CASE_RET(CL_INVALID_PIPE_SIZE);
        CLERROR_CASE_RET(CL_INVALID_DEVICE_QUEUE);
        CLERROR_CASE_RET(CL_INVALID_SPEC_ID);
        CLERROR_CASE_RET(CL_MAX_SIZE_RESTRICTION_EXCEEDED);
    default:
        return "<Unknown OpenCL Error>";
    }
}

#undef CLERROR_CASE_RET

}